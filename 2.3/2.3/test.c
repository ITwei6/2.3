#include <stdio.h>
//5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果：
//A选手说：B第二，我第三；
//B选手说：我第二，E第四；
//C选手说：我第一，D第二；
//D选手说：C最后，我第三；
//E选手说：我第四，A第一；
//比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。
//将现实问题转换为编程
//每个选手都说对一半？这个如何用编程来表示呢？
//每个选手都说了两句话，而只有一句话是对的
//如果把  两句话都看成两个判断句， 如果为真则结果为1 如果为假则结果为0
//所有两个判断式相加 等于1则表示只有一个判断句是真另外一个是假比如A选手说对一般表示：(b==2)+(a==3)==1
//把所有的可能性穷举出来，a可能是第1第2第……5，b可能是第1第2第……5，c可能是……，嵌套就可以了
//int main()
//{
//	int a=0;
//	int b=0;
//	int c=0;
//	int d=0;
//	int e=0;
//	for (a = 1; a <= 5; a++)
//	{
//		for (b = 1; b <= 5; b++)
//		{
//			for (c = 1; c <= 5; c++)
//			{
//				for (d = 1; d <= 5; d++)
//				{
//					for (e = 1; e <= 5; e++)//将所有可能性全部穷举出来，在这些可能性中，找题目所给的可能性是那种
//					{
//						if (((b == 2) + (a == 3) == 1) &&
//							((b == 2) + (e == 4) == 1) &&
//							((c == 1) + (d == 2) == 1) &&
//							((c == 5) + (d == 3) == 1) &&
//							((e == 4) + (a == 1) == 1))
//						{
//                          
//							if (a * b * c * d * e == 120)
//							{
//								printf("a=%d b=%d c=%d d=%d e=%d", a, b, c, d, e);
//							}
//						  }
//					}
//				}
//			}
//		}
//	}
//	return 0;
//}
#include <stdio.h>
//
//int checkData(int* p)
//{
//	int tmp[7] = { 0 }; //标记表，实际是哈希表的思路。一开始每个元素都是0
//	//用来表示名次是否有人了，如果p[0](a选手)的名次是3，则tmp[3]=1,表示第3名已经有人了
//	//如果p[1](b选手)的名次也是3，则进入if（）语句tmp[3]==1，
//	//直接返回0，这组成绩作废，再判断下组成绩。
//	//直到没有重复的 才可以才能返回1
//	
//	int i;
//	for (i = 0; i < 5; i++)
//	{
//		if (tmp[p[i]]==1) //如果这个位置的标记已经是1，则代表重复，直接返回0。
//		{
//			return 0;
//		}
//		tmp[p[i]] = 1; //如果不是，则给这个位置标记为1。
//	}
//	return 1; //全部标记完毕也没有出现重复的情况，代表OK。
//}
//
//int main()
//{
//	int p[5]; //0 1 2 3 4分别代表a b c d e
//
//	for (p[0] = 1; p[0] <= 5; p[0]++)
//	{
//		for (p[1] = 1; p[1] <= 5; p[1]++)
//		{
//			for (p[2] = 1; p[2] <= 5; p[2]++)
//			{
//				for (p[3] = 1; p[3] <= 5; p[3]++)
//				{
//					for (p[4] = 1; p[4] <= 5; p[4]++) //五层循环遍历
//					{
//						//这里是五个人的描述，由于比较表达式只有0和1两个结果，如果要两个条件有且只有一个为真，则可以用比较表达式的值总和为1的方式直接判定。别忘了还要判定不能并列。
//						if ((p[1] == 2) + (p[0] == 3) == 1 && //B第二，我第三
//							(p[1] == 2) + (p[4] == 4) == 1 && //我第二，E第四
//							(p[2] == 1) + (p[3] == 2) == 1 && //我第一，D第二
//							(p[2] == 5) + (p[3] == 3) == 1 && //C最后，我第三
//							(p[4] == 4) + (p[0] == 1) == 1 && //我第四，A第一
//							checkData(p) //不能并列||，如果checkData返回0，则整体都为假，如果返回1则为真
//							)
//						{
//							for (int i = 0; i < 5; i++)
//							{
//								printf("%d ", p[i]);
//							}
//							putchar('\n');
//						}
//					}
//				}
//			}
//		}
//	}
//
//	return 0;
//}
//int main()
//{
//	char killer = 0;
//	//分别假设凶手是a，b，c，d，看谁是凶手是符合三个人说真话，一个人
//	//说假话
//	for (killer = 'a'; killer <= 'd'; killer++)
//	{
//		if (('a' != killer) + (killer == 'c') + (killer == 'd') + (killer != 'd')==3)
//		{
//			printf("凶手是：%c", killer);
//		}
//	}
//	return 0;
//}
//#include <stdlib.h>
//int main()
//{
//	char arr[] = "xiao tao";
//	int i;
//	i = atoi(arr);
//	printf("%d", i);
//	return 0;
//}
int add(a, b);//先将b，a压栈进去，然后再调用函数，在调用函数之前就将参数传了过去
//以压栈的形式将参数，b，a压到栈上，等函数栈帧创建好后，再回头找到这两个值。
//从右到左压栈
//将函数的返回值先放进寄存器中，因为函数结束返回值变量就销毁了，但寄存器不会
//相当于将返回值放进一个全局变量里，等函数结束后，再见全局变量中的值拿出来
//函数调用结束后，空间销毁后，达到下一条指令，删除形参，释放空间
//
// 局部变量怎么创建？
//1.首先对函数分配栈帧空间
//2.初始化部分空间ccccc
//3.然后在函数栈帧里给局部变量分配一些空间
// 
// 
//为什么不初始化变量会变成随机值？
//因为变量是我们自己放进去的，如果初始化就会把随机值覆盖了，不初始化就会保留原来的随机值
// 
// 
//函数怎么传参的?
//在调用函数之前系统就先push push 把这两个参数从右向左开始压栈进去。
//而真正到函数调用的时候我们是通过指针的偏移量来找到形参
//
// 
//  形参与实参的关系
//形参确实是在我们压栈时开辟的空间，它和形参只是值上相同，但空间是独立的是不同的空间
//故形参是实参的临时拷贝，改变形参不会影响实参
// 
// 注意点：
// 
//1.我们在调用之前就把call指令的下一条指令地址记住了，存进去了压进去了
//2.我们在调用的时候就把main函数指向栈底的地址记住下，存进去压进去了，然后最好pop弹出去，把这个地址放进edp中，edp就更新到mian函数栈底去了
//3.寄存器是独立于内存是集成到CPU上的
//硬盘
//内存
//寄存器
//4.epd是存放当前栈空间函数的栈底地址，跟函数地址没有关系